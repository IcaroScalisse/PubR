} else {
warning(paste("API para", task_name, "retornou conte√∫do n√£o-JSON"))
return(NULL)
}
}
# ---------------------------------------------------------------
# 1. Fun√ß√µes Bitcoin
# ---------------------------------------------------------------
get_btc_price <- function() {
url <- "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=brl"
json <- safe_api_call(url, "buscar pre√ßo atual do Bitcoin")
if (is.null(json) || is.null(json$bitcoin$brl)) { return(NA) }
return(json$bitcoin$brl)
}
get_btc_history <- function(days = 365) {
# CoinGecko suporta per√≠odos longos (m√°x de 5 anos √© 1825 dias)
url <- paste0("https://api.coingecko.com/api/v3/coins/bitcoin/market-chart?vs_currency=brl&days=", days, "&interval=daily")
json <- safe_api_call(url, "buscar hist√≥rico do Bitcoin")
if (is.null(json) || is.null(json$prices)) {
# Retorna um dataframe de 1 linha com NA para evitar erros de estrutura no gr√°fico
return(data.frame(Date = as.Date(NA), price = as.numeric(NA)))
}
prices_data <- as.data.frame(json$prices)
colnames(prices_data) <- c("timestamp", "price")
prices_data$Date <- as.POSIXct(prices_data$timestamp / 1000, origin="1970-01-01") %>% as.Date()
return(prices_data %>% select(Date, price) %>% arrange(Date))
}
# ---------------------------------------------------------------
# 2. Fun√ß√µes D√≥lar (USD/BRL)
# ---------------------------------------------------------------
get_usd_price <- function() {
# Pega apenas o dia anterior (BCB s√≥ tem cota√ß√£o fechada)
end_date <- Sys.Date() - days(1)
start_str <- format(end_date, "%m-%d-%Y")
end_str <- format(end_date, "%m-%d-%Y")
url <- paste0("https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?@dataInicial='", start_str, "'&@dataFinalCotacao='", end_str, "'&$top=1&$format=json&$select=cotacaoVenda")
json <- safe_api_call(url, "buscar pre√ßo atual do D√≥lar")
if (is.null(json) || is.null(json$value) || nrow(json$value) == 0) { return(NA) }
return(json$value$cotacaoVenda[1])
}
get_usd_history <- function(days = 365) {
end_date <- Sys.Date()
start_date <- end_date - days
start_str <- format(start_date, "%m-%d-%Y")
end_str <- format(end_date, "%m-%d-%Y")
# Aumentado o $top para tentar cobrir o m√°ximo de dias solicitado (5 anos)
url <- paste0("https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?@dataInicial='", start_str, "'&@dataFinalCotacao='", end_str, "'&$top=5000&$format=json&$select=dataHoraCotacao,cotacaoVenda")
json <- safe_api_call(url, "buscar hist√≥rico do D√≥lar (BCB)")
if (is.null(json) || is.null(json$value)) {
return(data.frame(Date = as.Date(NA), price = as.numeric(NA)))
}
df <- json$value %>%
select(dataHoraCotacao, cotacaoVenda) %>%
rename(price = cotacaoVenda) %>%
mutate(Date = ymd_hms(dataHoraCotacao) %>% as.Date()) %>%
select(Date, price) %>%
distinct(Date, .keep_all = TRUE) %>%
arrange(Date)
return(df)
}
# ===============================================
# UI
# ===============================================
ui <- navbarPage(
title = "Rastreador de Investimentos",
theme = bs_theme(bootswatch = "flatly"),
tabPanel(
"Rastreamento & Gr√°ficos",
tags$header(
style = "background:#117a8b; padding:18px; margin-bottom:20px;
color:white; font-size:26px; font-weight:bold;",
"üìà Rastreamento de Lucro (Bitcoin & D√≥lar)"
),
sidebarLayout(
# Barra Lateral: Entrada de Compra
sidebarPanel(
tags$h4("1. Selecione o Ativo e o Per√≠odo"),
radioButtons(
"chart_select",
"Ativo:",
choices = c("Bitcoin (BTC/BRL)" = "btc", "D√≥lar (USD/BRL)" = "usd"),
selected = "btc"
),
selectInput(
"days_select",
"Per√≠odo de visualiza√ß√£o:",
choices = c("30 dias" = 30, "90 dias" = 90, "1 ano" = 365, "5 anos" = 1825),
selected = 90
),
tags$hr(),
tags$h4("2. Adicionar Nova Compra"),
tags$p(tags$b("Clique em um ponto no gr√°fico para selecionar a data!")),
# Campo de Data (Fonte Principal de Lookup)
dateInput("buy_date", "Data de Compra Selecionada:", value = Sys.Date()),
# EXIBI√á√ÉO DO PRE√áO CALCULADO (substitui o input manual)
tags$div(
class = "well",
style = "padding: 10px; background-color: #f8f9fa; border: 1px solid #dee2e6;",
tags$h5(tags$b("Pre√ßo de Compra (Calculado):")),
textOutput("calculated_buy_price_display")
),
# Campo de valor investido
numericInput("invested", "Valor Investido (BRL):", value = 0, min = 0, step = 10),
actionButton("add_buy", "Adicionar Compra", class = "btn btn-success"),
tags$hr(),
tags$h4("3. Gerenciar Compras"),
# Bot√£o Limpar Compras mantido aqui, pois gerencia as compras adicionadas
actionButton("clear_all", "Limpar Todas as Compras", class = "btn btn-danger")
),
# Painel Principal: Gr√°fico Interativo
mainPanel(
# Gr√°fico Din√¢mico
tags$h3(textOutput("chart_title_main")),
plotlyOutput("dynamic_chart", height = "400px")
# Tabela de Compras (REMOVIDA DAQUI)
)
),
tags$footer(
style = "background:#f0f0f0; padding:12px; margin-top:30px;
text-align:center; color:#444;",
HTML("Desenvolvido por √çcaro ‚Ä¢ Dados: CoinGecko API e BCB API")
)
),
# NOVA ABA PARA RESUMO DE LUCRO (TABELA MOVIDA PARA C√Å)
tabPanel(
"Resumo de Lucro Total",
fluidPage(
tags$header(
style = "background:#117a8b; padding:18px; margin-bottom:20px;
color:white; font-size:26px; font-weight:bold;",
"üí∞ Resumo de Lucro/Preju√≠zo e Hist√≥rico de Transa√ß√µes"
),
# 1. Tabela de Compras (MOVIDA PARA C√Å)
tags$h3("Hist√≥rico de Compras (Transa√ß√µes)"),
DTOutput("purchases_table"),
tags$hr(),
# 2. Resumo de Lucro/Preju√≠zo (LAYOUT HORIZONTAL)
tags$h3("Resumo de Lucro/Preju√≠zo Total"),
fluidRow(
column(6, tags$h4("Bitcoin (BTC)"), valueBoxOutput("btc_summary")),
column(6, tags$h4("D√≥lar (USD)"), valueBoxOutput("usd_summary"))
)
)
),
tabPanel(
"Sobre",
fluidPage(
tags$br(),
tags$h2("‚ÑπÔ∏è Sobre este aplicativo"),
tags$p("Este app rastreia investimentos em Bitcoin e D√≥lar. Use o gr√°fico para selecionar a data da sua compra e registre o valor investido."),
tags$hr(),
tags$p("Criado para fins educativos e demonstrativos.")
)
)
)
# ===============================================
# SERVER
# ===============================================
server <- function(input, output, session) {
# --- 1. Armazenamento de Compras (Dados Reativos) ---
purchases <- reactiveValues(df = data.frame(
ID = integer(),
Ativo = character(),
Data = as.Date(character()),
Preco_Compra = numeric(),
Investido_BRL = numeric(),
stringsAsFactors = FALSE
))
# --- 2. L√≥gica de Busca de Pre√ßo Atual ---
current_prices <- reactive({
list(
btc = get_btc_price(),
usd = get_usd_price()
)
})
# --- 3. L√≥gica do Gr√°fico ---
# Fun√ß√£o reativa para buscar DADOS de hist√≥rico
dynamic_history_data <- reactive({
days <- as.numeric(input$days_select)
if (input$chart_select == "btc") {
get_btc_history(days)
} else {
get_usd_history(days)
}
})
# Renderiza o T√çTULO do gr√°fico
output$chart_title_main <- renderText({
if (input$chart_select == "btc") {
"Varia√ß√£o Hist√≥rica do Bitcoin (BTC/BRL)"
} else {
"Taxa de C√¢mbio Hist√≥rica (USD/BRL - PTAX Venda)"
}
})
# Renderiza o GR√ÅFICO DIN√ÇMICO
output$dynamic_chart <- renderPlotly({
data <- dynamic_history_data()
chart_type <- input$chart_select
if (nrow(data) < 1 || is.na(data$price[1])) {
# Se falhar, renderiza um gr√°fico vazio com aviso
p <- ggplot() + labs(title = "‚ö†Ô∏è Dados indispon√≠veis ou falha na API.") + theme_minimal()
return(ggplotly(p))
}
# Configura√ß√µes din√¢micas
if (chart_type == "btc") {
color_line <- "#f7931a"
y_label <- "Pre√ßo (BRL)"
tooltip_text <- paste("Data:", data$Date, "<br>Pre√ßo: R$", round(data$price, 2))
} else {
color_line <- "#007c42"
y_label <- "Taxa (R$/USD)"
tooltip_text <- paste("Data:", data$Date, "<br>Taxa: R$", round(data$price, 4))
}
p <- ggplot(data, aes(x = Date, y = price, text = tooltip_text)) +
geom_line(color = color_line, size = 1) +
geom_point(color = color_line, size = 1.5) +
labs(x = "Data", y = y_label) +
theme_minimal()
ggplotly(p, tooltip = "text", source = "A") %>% layout(hovermode = 'x unified')
})
# --- 4. Intera√ß√£o: Clique no Gr√°fico (Atualiza Data) ---
observeEvent(event_data("plotly_click", source = "A"), {
click_data <- event_data("plotly_click", source = "A")
req(click_data)
history_data <- dynamic_history_data()
if (nrow(history_data) < 1 || is.na(history_data$price[1])) {
warning("Dados hist√≥ricos indispon√≠veis. N√£o √© poss√≠vel registrar a compra por clique.")
return()
}
clicked_index <- click_data$pointNumber + 1
if (length(clicked_index) == 1 && clicked_index >= 1 && clicked_index <= nrow(history_data)) {
clicked_row <- history_data[clicked_index, ]
if (!is.na(clicked_row$price) && clicked_row$price > 0) {
# Atualiza APENAS a data, o pre√ßo ser√° calculado reativamente abaixo
updateDateInput(session, "buy_date", value = clicked_row$Date)
} else {
warning("Pre√ßo inv√°lido no ponto clicado.")
}
} else {
warning("√çndice de clique inconsistente ou fora do limite do dataframe.")
}
})
# --- 5. L√≥gica de Lookup de Pre√ßo Pela Data (NOVO) ---
calculated_buy_price <- reactive({
# Requer o ativo e a data selecionada
req(input$chart_select, input$buy_date)
# Usa o per√≠odo m√°ximo de 5 anos (1825 dias) para garantir que o lookup encontre a data
days_for_lookup <- 1825
if (input$chart_select == "btc") {
data <- get_btc_history(days_for_lookup)
} else {
data <- get_usd_history(days_for_lookup)
}
# Procura o pre√ßo na data espec√≠fica
if (nrow(data) > 0 && !is.na(data$Date[1])) {
price_row <- data %>%
filter(Date == as.Date(input$buy_date)) %>%
slice_tail(n = 1) # Pega o √∫ltimo/√∫nico registro para o dia
if (nrow(price_row) > 0 && !is.na(price_row$price)) {
return(round(price_row$price[1], 4))
}
}
# Se o lookup falhar ou pre√ßo for 0
return(0)
})
# Exibe o pre√ßo calculado na UI (NOVO)
output$calculated_buy_price_display <- renderText({
price <- calculated_buy_price()
if (price > 0) {
paste0("R$", format(price, big.mark = ".", decimal.mark = ",", nsmall = 4))
} else {
"Pre√ßo indispon√≠vel para esta data/ativo."
}
})
# --- 6. Adicionar Nova Compra (Usa o pre√ßo calculado) ---
observeEvent(input$add_buy, {
calculated_price <- calculated_buy_price()
# Requer a data, pre√ßo calculado > 0 e valor investido > 0
req(input$buy_date, calculated_price > 0, input$invested > 0)
# Cria o novo registro
new_id <- if (nrow(purchases$df) == 0) 1 else max(purchases$df$ID) + 1
new_row <- data.frame(
ID = new_id,
Ativo = ifelse(input$chart_select == "btc", "Bitcoin (BTC)", "D√≥lar (USD)"),
Data = as.Date(input$buy_date),
Preco_Compra = calculated_price, # Usa o pre√ßo calculado!
Investido_BRL = input$invested,
stringsAsFactors = FALSE
)
# Adiciona √† lista reativa
purchases$df <- rbind(purchases$df, new_row)
# Limpa o valor investido para a pr√≥xima entrada
updateNumericInput(session, "invested", value = 0)
})
# --- 7. Limpar Compras ---
observeEvent(input$clear_all, {
purchases$df <- data.frame(
ID = integer(), Ativo = character(), Data = as.Date(character()),
Preco_Compra = numeric(), Investido_BRL = numeric(), stringsAsFactors = FALSE
)
})
# --- 8. Tabela de Compras (Transa√ß√µes) (AGORA COM LUCRO INDIVIDUAL) ---
output$purchases_table <- renderDT({
# Obter pre√ßos atuais
current_p <- current_prices()
btc_price <- current_p$btc
usd_price <- current_p$usd
# Adicionar colunas de Quantidade e Lucro
data_calculated <- purchases$df %>%
# 1. Calcular a quantidade comprada
mutate(Quantidade = Investido_BRL / Preco_Compra) %>%
# 2. Calcular o Valor Atual e Lucro
mutate(
Preco_Atual = if_else(Ativo == "Bitcoin (BTC)", btc_price, usd_price),
# Se o pre√ßo atual for NA (API Offline), o c√°lculo de lucro/valor atual ser√° NA
Valor_Atual = Quantidade * Preco_Atual,
Lucro = Valor_Atual - Investido_BRL,
# CORRIGIDO: Calculamos o decimal (0.01) e DT::formatPercentage faz o *100 e adiciona o '%'
Lucro_Perc = (Lucro / Investido_BRL)
) %>%
# Selecionar e renomear colunas para exibi√ß√£o
select(
Ativo,
Data,
Preco_Compra,
Preco_Atual,
Investido_BRL,
Lucro,
Lucro_Perc
) %>%
rename(
`Pre√ßo Compra` = Preco_Compra,
`Pre√ßo Atual` = Preco_Atual,
`Investido (BRL)` = Investido_BRL,
`Lucro (BRL)` = Lucro,
`Lucro (%)` = Lucro_Perc
)
# Definir as colunas para formata√ß√£o
currency_cols <- c('Pre√ßo Compra', 'Pre√ßo Atual', 'Investido (BRL)', 'Lucro (BRL)')
percent_cols <- 'Lucro (%)'
datatable(
data_calculated,
rownames = FALSE,
options = list(
pageLength = 5,
dom = 'tp',
language = list(
decimal = ",", thousands = ".", search = "Buscar:",
lengthMenu = "Mostrar _MENU_ registros",
info = "Mostrando _START_ ate _END_ de _TOTAL_ registros",
paginate = list(previous = "Anterior", `next` = "Proximo")
)
)
) %>%
formatCurrency(currency_cols, currency = "R$", interval = 3, mark = ".", digits = 2) %>%
# A fun√ß√£o formatPercentage multiplica o valor por 100 e adiciona o '%'
formatPercentage(percent_cols, digits = 2, mark = ",")
})
# --- 9. C√°lculo de Lucro Total (Mantido) ---
total_summary <- reactive({
current_p <- current_prices()
df_temp <- purchases$df
if (nrow(df_temp) == 0) {
return(list(btc = 0, usd = 0))
}
df_temp <- df_temp %>%
mutate(Quantidade = Investido_BRL / Preco_Compra)
df_summary <- df_temp %>%
group_by(Ativo) %>%
summarise(
Total_Investido = sum(Investido_BRL),
Total_Quantidade = sum(Quantidade),
.groups = 'drop'
)
btc_calc <- df_summary %>% filter(Ativo == "Bitcoin (BTC)")
usd_calc <- df_summary %>% filter(Ativo == "D√≥lar (USD)")
# Se o pre√ßo atual falhar (NA), o lucro √© NA
btc_lucro <- 0
if (nrow(btc_calc) > 0 && !is.na(current_p$btc)) {
btc_valor_atual <- btc_calc$Total_Quantidade * current_p$btc
btc_lucro <- btc_valor_atual - btc_calc$Total_Investido
} else if (nrow(btc_calc) > 0) {
btc_lucro <- NA
}
usd_lucro <- 0
if (nrow(usd_calc) > 0 && !is.na(current_p$usd)) {
usd_valor_atual <- usd_calc$Total_Quantidade * current_p$usd
usd_lucro <- usd_valor_atual - usd_calc$Total_Investido
} else if (nrow(usd_calc) > 0) {
usd_lucro <- NA
}
list(btc = btc_lucro, usd = usd_lucro)
})
# --- 10. Value Boxes (Resumo Visual) ---
# BTC Summary
output$btc_summary <- renderValueBox({
lucro <- total_summary()$btc
if (is.na(lucro)) {
display_value <- "API OFFLINE"
subtitle_text <- "C√°lculo indispon√≠vel"
cor <- "black"
} else {
display_value <- paste0("R$", format(lucro, big.mark = ".", decimal.mark = ",", nsmall = 2))
subtitle_text <- "Lucro/Preju√≠zo Total"
cor <- if (lucro > 0) "green" else if (lucro < 0) "red" else "blue"
}
valueBox(
display_value,
subtitle_text,
icon = icon("bitcoin"),
color = cor
)
})
# USD Summary
output$usd_summary <- renderValueBox({
lucro <- total_summary()$usd
if (is.na(lucro)) {
display_value <- "API OFFLINE"
subtitle_text <- "C√°lculo indispon√≠vel"
cor <- "black"
} else {
display_value <- paste0("R$", format(lucro, big.mark = ".", decimal.mark = ",", nsmall = 2))
subtitle_text <- "Lucro/Preju√≠zo Total"
cor <- if (lucro > 0) "green" else if (lucro < 0) "red" else "blue"
}
valueBox(
display_value,
subtitle_text,
icon = icon("dollar-sign"),
color = cor
)
})
}
# ===============================================
# RUN APP
# ===============================================
shinyApp(ui, server)
setwd("~/Desktop/PubR")
f <- list.files(".", recursive = TRUE, full.names = TRUE, include.dirs = TRUE)
bad <- f[is.na(file.info(f)$isdir)]
bad
devtools::check_built("PubR_0.1.tar.gz")
install.packages("PubR")
remove.packages("PubR")
"PubR" %in% installed.packages()[, "Package"]
.libPaths()
devtools::install_github("IcaroScalisse/PubR")
setwd("Desktop/PubR")
setwd("~/Desktop/PubR)
dads
q()
setwd("~/Desktop/PubR")
rm -f .Rprofile
unlink(".Rprofile")
rm -rf renv
devtools::document()
devtools::build()
devtools::install_github("IcaroScalisse/PubR", force = TRUE)
library("PubR")
pubmed_wordcloud("KIR2DL2")
pubmed_year_publication("2025")
pubmed_top_authors("KIR2DL2")
top_journals("KIR2DL2")
top_journals("KIR2DL2", batch_size = 300)
devtools::load_all()
pubmed_top_authors("KIR2DL2")
top_journals("KIR2DL2", batch_size = 300)
get_top_words_by_year("2025")
devtools::load_all()
top_journals("KIR2DL2", batch_size = 300)
devtools::load_all()
remove.packages("PubR")
devtools::install_github("IcaroScalisse/PubR")
devtools::load_all()
top_journals("KIR2DL2", batch_size = 300)
devtools::load_all()
top_journals("KIR2DL2", batch_size = 300)
res <- entrez_search(
db = "pubmed",
term = "KIR2DL2",
retmax = 500,
usehistory = TRUE
)
str(res)
res <- entrez_search(
db = "pubmed",
term = "KIR2DL2",
retmax = 500,
use_history = TRUE
)
str(res)
res <- entrez_search(
db = "pubmed",
term = "KIR2DL2",
retmax = 500,
use_history = TRUE
)
str(res)
devtools::load_all()
top_journals("KIR2DL2", batch_size = 300)
usethis::use_readme_md()
devtools::load_all()
devtools::install_github("IcaroScalisse/PubR")
devtools::load_all()
pubmed_wordcloud("Artificial Intelligence", n_results = 400)
pubmed_year_publication("artificial intelligence", year_range = c(2010, 2024))
artificial intelligence
pubmed_year_publication("artificial intelligence", year_range = c(2010, 2024))
pubmed_year_publication("artificial intelligence", year_range = c(2010, 2025))
pubmed_top_authors("CRISPR", top_n = 30)
top_journals("immunogenetics", top_n = 15)
top_journals("immunogenetics", max_results = 3000, top_n = 15)
get_top_words_by_year(2020, top_n = 30)
